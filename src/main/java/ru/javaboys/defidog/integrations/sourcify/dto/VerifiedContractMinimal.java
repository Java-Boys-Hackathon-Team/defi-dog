/*
 * Sourcify APIv2
 * Welcome to the Sourcify's APIv2.  Important differences between the deprecated legacy API and the new APIv2: - **Ticketing**: The verfication requests resolve into tickets/verification jobs.    - Previously the verification happened during the HTTP request, which resulted in timeouts if compilation took longer - **Standard JSON as default**: In the current design we take the standard JSON format as our main verification endpoint. We still support verification with metadata at `/v2/verify/metadata`. - **Lean API**: We keep the number of endpoints minimal compared to v1. We won't have a session API.  - **Detailed contract response**: Prev. we only returned contract files of a contract. Now we can return details at `/contract/{chainId}/{address}`.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@sourcify.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ru.javaboys.defidog.integrations.sourcify.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;

import java.time.OffsetDateTime;
import java.util.Objects;

/**
 * VerifiedContractMinimal
 */
@JsonPropertyOrder({
  VerifiedContractMinimal.JSON_PROPERTY_MATCH,
  VerifiedContractMinimal.JSON_PROPERTY_CREATION_MATCH,
  VerifiedContractMinimal.JSON_PROPERTY_RUNTIME_MATCH,
  VerifiedContractMinimal.JSON_PROPERTY_CHAIN_ID,
  VerifiedContractMinimal.JSON_PROPERTY_ADDRESS,
  VerifiedContractMinimal.JSON_PROPERTY_VERIFIED_AT,
  VerifiedContractMinimal.JSON_PROPERTY_MATCH_ID
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-08T01:55:37.009934+03:00[Europe/Moscow]", comments = "Generator version: 7.7.0")
public class VerifiedContractMinimal {
  /**
   * Gets or Sets match
   */
  public enum MatchEnum {
    MATCH("match"),
    
    EXACT_MATCH("exact_match"),
    
    NULL("null");

    private String value;

    MatchEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MatchEnum fromValue(String value) {
      for (MatchEnum b : MatchEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_MATCH = "match";
  private MatchEnum match;

  /**
   * Gets or Sets creationMatch
   */
  public enum CreationMatchEnum {
    MATCH("match"),
    
    EXACT_MATCH("exact_match"),
    
    NULL("null");

    private String value;

    CreationMatchEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static CreationMatchEnum fromValue(String value) {
      for (CreationMatchEnum b : CreationMatchEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_CREATION_MATCH = "creationMatch";
  private CreationMatchEnum creationMatch;

  /**
   * Gets or Sets runtimeMatch
   */
  public enum RuntimeMatchEnum {
    MATCH("match"),
    
    EXACT_MATCH("exact_match"),
    
    NULL("null");

    private String value;

    RuntimeMatchEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RuntimeMatchEnum fromValue(String value) {
      for (RuntimeMatchEnum b : RuntimeMatchEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RUNTIME_MATCH = "runtimeMatch";
  private RuntimeMatchEnum runtimeMatch;

  public static final String JSON_PROPERTY_CHAIN_ID = "chainId";
  private String chainId;

  public static final String JSON_PROPERTY_ADDRESS = "address";
  private String address;

  public static final String JSON_PROPERTY_VERIFIED_AT = "verifiedAt";
  private OffsetDateTime verifiedAt;

  public static final String JSON_PROPERTY_MATCH_ID = "matchId";
  private String matchId;

  public VerifiedContractMinimal() {
  }

  public VerifiedContractMinimal match(MatchEnum match) {
    
    this.match = match;
    return this;
  }

  /**
   * Get match
   * @return match
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public MatchEnum getMatch() {
    return match;
  }


  @JsonProperty(JSON_PROPERTY_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMatch(MatchEnum match) {
    this.match = match;
  }

  public VerifiedContractMinimal creationMatch(CreationMatchEnum creationMatch) {
    
    this.creationMatch = creationMatch;
    return this;
  }

  /**
   * Get creationMatch
   * @return creationMatch
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREATION_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public CreationMatchEnum getCreationMatch() {
    return creationMatch;
  }


  @JsonProperty(JSON_PROPERTY_CREATION_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreationMatch(CreationMatchEnum creationMatch) {
    this.creationMatch = creationMatch;
  }

  public VerifiedContractMinimal runtimeMatch(RuntimeMatchEnum runtimeMatch) {
    
    this.runtimeMatch = runtimeMatch;
    return this;
  }

  /**
   * Get runtimeMatch
   * @return runtimeMatch
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RUNTIME_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public RuntimeMatchEnum getRuntimeMatch() {
    return runtimeMatch;
  }


  @JsonProperty(JSON_PROPERTY_RUNTIME_MATCH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRuntimeMatch(RuntimeMatchEnum runtimeMatch) {
    this.runtimeMatch = runtimeMatch;
  }

  public VerifiedContractMinimal chainId(String chainId) {
    
    this.chainId = chainId;
    return this;
  }

  /**
   * Get chainId
   * @return chainId
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CHAIN_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getChainId() {
    return chainId;
  }


  @JsonProperty(JSON_PROPERTY_CHAIN_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setChainId(String chainId) {
    this.chainId = chainId;
  }

  public VerifiedContractMinimal address(String address) {
    
    this.address = address;
    return this;
  }

  /**
   * Contract Address in hex string. Can be checksummed or not (i.e. can contain capital letters)
   * @return address
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getAddress() {
    return address;
  }


  @JsonProperty(JSON_PROPERTY_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAddress(String address) {
    this.address = address;
  }

  public VerifiedContractMinimal verifiedAt(OffsetDateTime verifiedAt) {
    
    this.verifiedAt = verifiedAt;
    return this;
  }

  /**
   * Get verifiedAt
   * @return verifiedAt
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_VERIFIED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getVerifiedAt() {
    return verifiedAt;
  }


  @JsonProperty(JSON_PROPERTY_VERIFIED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVerifiedAt(OffsetDateTime verifiedAt) {
    this.verifiedAt = verifiedAt;
  }

  public VerifiedContractMinimal matchId(String matchId) {
    
    this.matchId = matchId;
    return this;
  }

  /**
   * Get matchId
   * @return matchId
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MATCH_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getMatchId() {
    return matchId;
  }


  @JsonProperty(JSON_PROPERTY_MATCH_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMatchId(String matchId) {
    this.matchId = matchId;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VerifiedContractMinimal verifiedContractMinimal = (VerifiedContractMinimal) o;
    return Objects.equals(this.match, verifiedContractMinimal.match) &&
        Objects.equals(this.creationMatch, verifiedContractMinimal.creationMatch) &&
        Objects.equals(this.runtimeMatch, verifiedContractMinimal.runtimeMatch) &&
        Objects.equals(this.chainId, verifiedContractMinimal.chainId) &&
        Objects.equals(this.address, verifiedContractMinimal.address) &&
        Objects.equals(this.verifiedAt, verifiedContractMinimal.verifiedAt) &&
        Objects.equals(this.matchId, verifiedContractMinimal.matchId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(match, creationMatch, runtimeMatch, chainId, address, verifiedAt, matchId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VerifiedContractMinimal {\n");
    sb.append("    match: ").append(toIndentedString(match)).append("\n");
    sb.append("    creationMatch: ").append(toIndentedString(creationMatch)).append("\n");
    sb.append("    runtimeMatch: ").append(toIndentedString(runtimeMatch)).append("\n");
    sb.append("    chainId: ").append(toIndentedString(chainId)).append("\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    verifiedAt: ").append(toIndentedString(verifiedAt)).append("\n");
    sb.append("    matchId: ").append(toIndentedString(matchId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

